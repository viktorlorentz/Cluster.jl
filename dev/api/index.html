<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Cluster.jl</title><meta name="title" content="API · Cluster.jl"/><meta property="og:title" content="API · Cluster.jl"/><meta property="twitter:title" content="API · Cluster.jl"/><meta name="description" content="Documentation for Cluster.jl."/><meta property="og:description" content="Documentation for Cluster.jl."/><meta property="twitter:description" content="Documentation for Cluster.jl."/><meta property="og:url" content="https://viktorlorentz.github.io/Cluster.jl/api/"/><meta property="twitter:url" content="https://viktorlorentz.github.io/Cluster.jl/api/"/><link rel="canonical" href="https://viktorlorentz.github.io/Cluster.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Cluster.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li><li><a class="tocitem" href="#KMeans-/-KMeans-Clustering-Algorithm"><span>KMeans / KMeans++ Clustering Algorithm</span></a></li><li><a class="tocitem" href="#Bisecting-KMeans-Clustering-Algorithm"><span>Bisecting KMeans Clustering Algorithm</span></a></li><li><a class="tocitem" href="#Distributional-Clustering-Method"><span>Distributional Clustering Method</span></a></li><li><a class="tocitem" href="#Full-list-of-available-functions"><span>Full list of available functions</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/viktorlorentz/Cluster.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/viktorlorentz/Cluster.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="#Utility-functions">Utility functions</a></li><li><a href="#KMeans-/-KMeans-Clustering-Algorithm">KMeans / KMeans++ Clustering Algorithm</a></li><li><a href="#Bisecting-KMeans-Clustering-Algorithm">Bisecting KMeans Clustering Algorithm</a></li><li><a href="#Distributional-Clustering-Method">Distributional Clustering Method</a></li><li><a href="#Full-list-of-available-functions">Full list of available functions</a></li></ul><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><p>All functions used by all algorithms.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, Symbol}-api" href="#Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, Symbol}-api"><code>Cluster.init_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_centroids(X::Matrix{Float64}, K::Int64, mode::Symbol)</code></pre><p>Initializes centroids for the clustering algorithm based on the specified mode.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>K::Int64</code>: Number of clusters.</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>.</li></ul><p><strong>Output</strong></p><ul><li>Returns a matrix of initialized centroid coordinates.</li></ul><p><strong>Algorithm</strong></p><ol><li>If <code>mode</code> is <code>:random</code>:<ul><li>Randomly select K data points from X as initial centroids.</li></ul></li><li>If <code>mode</code> is <code>:kmeanspp</code>:<ul><li>Initialize the first centroid randomly.</li><li>For each subsequent centroid:   a. Compute the distance from each data point to the nearest centroid.   b. Select the next centroid with probability proportional to the squared distance.</li></ul></li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; centroids = init_centroids(X, 3, :kmeanspp)
3×2 Matrix{Float64}:
 0.386814  0.619566
 0.170768  0.0176449
 0.38688   0.398064</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/utils.jl#L1-L32">source</a></section></article><h2 id="KMeans-/-KMeans-Clustering-Algorithm"><a class="docs-heading-anchor" href="#KMeans-/-KMeans-Clustering-Algorithm">KMeans / KMeans++ Clustering Algorithm</a><a id="KMeans-/-KMeans-Clustering-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#KMeans-/-KMeans-Clustering-Algorithm" title="Permalink"></a></h2><ul><li>Initializes centroids using either random selection or KMeans++.</li><li>Iteratively assigns points to the nearest centroid.</li><li>Updates centroids based on the mean of assigned points.</li><li>Stops when centroids converge or after a maximum number of iterations.</li></ul><p>References:</p><ul><li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">Scikit-Learn KMeans Documentation</a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.KMeans-Tuple{}-api-2" href="#Cluster.KMeans-Tuple{}-api-2"><code>Cluster.KMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KMeans(; k::Int=3, mode::Symbol=:kmeanspp, max_try::Int=100, tol::Float64=1e-4)</code></pre><p>Constructor for the KMeans struct.</p><p><strong>Input</strong></p><ul><li><code>k::Int</code>: Number of clusters (default: 3).</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code> (default: :kmeanspp).</li><li><code>max_try::Int</code>: Maximum number of iterations (default: 100).</li><li><code>tol::Float64</code>: Tolerance for convergence (default: 1e-4).</li></ul><p><strong>Output</strong></p><ul><li>Returns an instance of <code>KMeans</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3, mode=:kmeanspp, max_try=100, tol=1e-4)
KMeans(3, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.KMeans-api-2" href="#Cluster.KMeans-api-2"><code>Cluster.KMeans</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct KMeans</code></pre><p>A mutable struct for the KMeans clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of clusters.</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>.</li><li><code>max_try::Int</code>: Maximum number of iterations.</li><li><code>tol::Float64</code>: Tolerance for convergence.</li><li><code>centroids::Array{Float64,2}</code>: Matrix of centroid coordinates.</li><li><code>labels::Array{Int,1}</code>: Vector of labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3, mode=:kmeanspp, max_try=100, tol=1e-4)
KMeans(3, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.assign_center-Tuple{Matrix{Float64}}-api-2" href="#Cluster.assign_center-Tuple{Matrix{Float64}}-api-2"><code>Cluster.assign_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_center(D::Matrix{Float64})</code></pre><p>Assigns each data point to the nearest centroid based on the distance matrix D.</p><p><strong>Input</strong></p><ul><li><code>D::Matrix{Float64}</code>: Distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of labels where each element is the index of the nearest centroid for the corresponding data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = rand(100, 3)
julia&gt; labels = assign_center(D)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L158-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}-api-2" href="#Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}-api-2"><code>Cluster.compute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_distance(X::Matrix{Float64}, centroids::Matrix{Float64})</code></pre><p>Computes the distance between each data point in X and each centroid.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>centroids::Matrix{Float64}</code>: Matrix of centroid coordinates.</li></ul><p><strong>Output</strong></p><ul><li>Returns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; centroids = rand(3, 2)
julia&gt; D = compute_distance(X, centroids)
100×3 Matrix{Float64}:
 0.181333  0.539578  0.306867
 0.754863  0.48797   0.562147
 0.205116  0.360735  0.127107
 0.154926  0.552747  0.323433
 ⋮
 0.434321  0.321914  0.261909
 0.773258  0.291669  0.513668
 0.607547  0.310411  0.38714</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L117-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.fit!-Tuple{KMeans, Matrix{Float64}}-api-2" href="#Cluster.fit!-Tuple{KMeans, Matrix{Float64}}-api-2"><code>Cluster.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::KMeans, X::Matrix{Float64})</code></pre><p>Fits the KMeans model to the data matrix X.</p><p><strong>Input</strong></p><ul><li><code>model::KMeans</code>: An instance of <code>KMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Modifies the <code>model</code> in-place to fit the data.</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize centroids.</li><li>Iterate up to <code>max_try</code> times:  a. Compute distances between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the mean of assigned data points.  d. Check for convergence based on <code>tol</code>.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3)
julia&gt; X = rand(100, 2)
julia&gt; fit!(model, X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L65-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.predict-Tuple{KMeans, Matrix{Float64}}-api-2" href="#Cluster.predict-Tuple{KMeans, Matrix{Float64}}-api-2"><code>Cluster.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(model::KMeans, X::Matrix{Float64})</code></pre><p>Predicts the cluster labels for new data points based on the fitted model.</p><p><strong>Input</strong></p><ul><li><code>model::KMeans</code>: An instance of <code>KMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of predicted labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3)
julia&gt; X_train = rand(100, 2)
julia&gt; fit!(model, X_train)
julia&gt; X_test = rand(10, 2)
julia&gt; labels = predict(model, X_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L212-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}-api-2" href="#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}-api-2"><code>Cluster.update_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::KMeans)</code></pre><p>Updates the centroids based on the current assignment of data points to centroids.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>label_vector::Vector{Int64}</code>: Vector of labels for each data point.</li><li><code>model::KMeans</code>: An instance of <code>KMeans</code>.</li></ul><p><strong>Output</strong></p><ul><li>Returns a matrix of updated centroid coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; labels = rand(1:3, 100)
julia&gt; model = KMeans(k=3)
julia&gt; centroids = update_centroids(X, labels, model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L179-L199">source</a></section></article><h2 id="Bisecting-KMeans-Clustering-Algorithm"><a class="docs-heading-anchor" href="#Bisecting-KMeans-Clustering-Algorithm">Bisecting KMeans Clustering Algorithm</a><a id="Bisecting-KMeans-Clustering-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Bisecting-KMeans-Clustering-Algorithm" title="Permalink"></a></h2><ul><li>Starts with a single cluster containing all data points.</li><li>Recursively splits clusters based on the highest SSE until <code>k</code> clusters are obtained.</li><li>Uses standard KMeans for cluster splitting.</li></ul><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/K-means_clustering#Bisecting_K-means">Bisecting KMeans: An Improved Version of KMeans</a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.BKMeans-Tuple{}-api-3" href="#Cluster.BKMeans-Tuple{}-api-3"><code>Cluster.BKMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BKMeans(; k::Int=3, kmeans::KMeans=KMeans(k=2, mode=:kmeanspp))</code></pre><p>Constructor for the BKMeans struct.</p><p><strong>Input</strong></p><ul><li><code>k::Int</code>: Number of clusters (default: 3).</li><li><code>kmeans::KMeans</code>: An instance of the KMeans struct used for bisecting (default: KMeans(k=2, mode=:kmeanspp)).</li></ul><p><strong>Output</strong></p><ul><li>Returns an instance of <code>BKMeans</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
BKMeans(3, KMeans(2, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L26-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.BKMeans-api-3" href="#Cluster.BKMeans-api-3"><code>Cluster.BKMeans</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BKMeans</code></pre><p>A mutable struct for the Bisecting KMeans clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of clusters.</li><li><code>kmeans::KMeans</code>: An instance of the KMeans struct used for bisecting.</li><li><code>labels::Array{Int,1}</code>: Vector of labels for each data point.</li><li><code>centroids::Matrix{Float64}</code>: Matrix of centroid coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
BKMeans(3, KMeans(2, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}-api-3" href="#Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}-api-3"><code>Cluster.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::BKMeans, X::Matrix{Float64})</code></pre><p>Fits the BKMeans model to the data matrix X.</p><p><strong>Input</strong></p><ul><li><code>model::BKMeans</code>: An instance of <code>BKMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Modifies the <code>model</code> in-place to fit the data.</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize clusters with the entire dataset.</li><li>While the number of clusters is less than <code>k</code>:  a. Compute the sum of squared errors (SSE) for each cluster.  b. Select the cluster with the highest SSE.  c. Apply KMeans to bisect the selected cluster.  d. Replace the selected cluster with the two resulting clusters.</li><li>Assign labels and centroids based on the final clusters.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
julia&gt; X = rand(100, 2)
julia&gt; fit!(model, X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L55-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.predict-Tuple{BKMeans, Matrix{Float64}}-api-3" href="#Cluster.predict-Tuple{BKMeans, Matrix{Float64}}-api-3"><code>Cluster.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(model::BKMeans, X::Matrix{Float64})</code></pre><p>Predicts the cluster labels for new data points based on the fitted BKMeans model.</p><p><strong>Input</strong></p><ul><li><code>model::BKMeans</code>: An instance of <code>BKMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of predicted labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
julia&gt; X_train = rand(100, 2)
julia&gt; fit!(model, X_train)
julia&gt; X_test = rand(10, 2)
julia&gt; labels = predict(model, X_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L116-L137">source</a></section></article><h2 id="Distributional-Clustering-Method"><a class="docs-heading-anchor" href="#Distributional-Clustering-Method">Distributional Clustering Method</a><a id="Distributional-Clustering-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Distributional-Clustering-Method" title="Permalink"></a></h2><p>References:</p><ul><li><a href="https://arxiv.org/abs/1911.05940">Krishna, A., Mak, S. and Joseph, R., 2019. Distributional clustering: A distribution-preserving clustering method. arXiv preprint arXiv:1911.05940</a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.DC-Tuple{}-api-4" href="#Cluster.DC-Tuple{}-api-4"><code>Cluster.DC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DC(; k::Int=3, mode::Symbol=:kmeanspp, max_try::Int=100, tol::Float64=1e-4)</code></pre><p>Constructor for the DC struct.</p><p><strong>Input</strong></p><ul><li><code>k::Int</code>: Number of clusters (default: 3).</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>(default: :kmeanspp).</li><li><code>max_try::Int</code>: Maximum number of iterations (default: 100).</li><li><code>tol::Float64</code>: Tolerance for convergence (default: 1e-4).</li></ul><p><strong>Output</strong></p><ul><li>Returns an instance of <code>DC</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3, mode=:kmeanspp, max_try=100, tol=1e-4)
DC(3, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.DC-api-4" href="#Cluster.DC-api-4"><code>Cluster.DC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DC</code></pre><p>A mutable struct for the Density-based Clustering (DC) algorithm.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of clusters.</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>.</li><li><code>max_try::Int</code>: Maximum number of iterations.</li><li><code>tol::Float64</code>: Tolerance for convergence.</li><li><code>centroids::Array{Float64,2}</code>: Matrix of centroid coordinates.</li><li><code>labels::Array{Int,1}</code>: Vector of labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3, mode=:random, max_try=100, tol=1e-4)
DC(3, :random, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}-api-4" href="#Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}-api-4"><code>Cluster.compute_objective_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_objective_function(X::Matrix{Float64}, centroids::Matrix{Float64}; p=2, delta=0.0001)</code></pre><p>Computes the objective function for the DC algorithm.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>centroids::Matrix{Float64}</code>: Matrix of centroid coordinates.</li><li><code>p</code>: Power parameter for the distance metric (default: 2).</li><li><code>delta</code>: Small constant to avoid division by zero (default: 0.0001).</li></ul><p><strong>Output</strong></p><ul><li>Returns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; centroids = rand(3, 2)
julia&gt; D = compute_objective_function(X, centroids)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.fit!-Tuple{DC, Matrix{Float64}}-api-4" href="#Cluster.fit!-Tuple{DC, Matrix{Float64}}-api-4"><code>Cluster.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::DC, X::Matrix{Float64})</code></pre><p>Fits the DC model to the data matrix X.</p><p><strong>Input</strong></p><ul><li><code>model::DC</code>: An instance of <code>DC</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Modifies the <code>model</code> in-place to fit the data.</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize centroids.</li><li>Iterate up to <code>max_try</code> times:  a. Compute the objective function between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the current assignment.  d. Check for convergence based on <code>tol</code>.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3)
julia&gt; X = rand(100, 2)
julia&gt; fit!(model, X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L144-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.predict-Tuple{DC, Matrix{Float64}}-api-4" href="#Cluster.predict-Tuple{DC, Matrix{Float64}}-api-4"><code>Cluster.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(model::DC, X::Matrix{Float64})</code></pre><p>Predicts the cluster labels for new data points based on the fitted DC model.</p><p><strong>Input</strong></p><ul><li><code>model::DC</code>: An instance of <code>DC</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of predicted labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3)
julia&gt; X_train = rand(100, 2)
julia&gt; fit!(model, X_train)
julia&gt; X_test = rand(10, 2)
julia&gt; labels = predict(model, X_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L194-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}-api-4" href="#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}-api-4"><code>Cluster.update_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::DC; delta=0.0001)</code></pre><p>Updates the centroids based on the current assignment of data points to centroids.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>label_vector::Vector{Int64}</code>: Vector of labels for each data point.</li><li><code>model::DC</code>: An instance of <code>DC</code>.</li><li><code>delta</code>: Small constant to avoid division by zero (default: 0.0001).</li></ul><p><strong>Output</strong></p><ul><li>Returns a matrix of updated centroid coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; labels = rand(1:3, 100)
julia&gt; model = DC(k=3)
julia&gt; centroids = update_centroids(X, labels, model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L99-L120">source</a></section></article><h2 id="Full-list-of-available-functions"><a class="docs-heading-anchor" href="#Full-list-of-available-functions">Full list of available functions</a><a id="Full-list-of-available-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Full-list-of-available-functions" title="Permalink"></a></h2><ul><li><a href="#Cluster.BKMeans"><code>Cluster.BKMeans</code></a></li><li><a href="#Cluster.BKMeans-Tuple{}"><code>Cluster.BKMeans</code></a></li><li><a href="#Cluster.DC-Tuple{}"><code>Cluster.DC</code></a></li><li><a href="#Cluster.DC"><code>Cluster.DC</code></a></li><li><a href="#Cluster.KMeans"><code>Cluster.KMeans</code></a></li><li><a href="#Cluster.KMeans-Tuple{}"><code>Cluster.KMeans</code></a></li><li><a href="#Cluster.assign_center-Tuple{Matrix{Float64}}"><code>Cluster.assign_center</code></a></li><li><a href="#Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}"><code>Cluster.compute_distance</code></a></li><li><a href="#Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}"><code>Cluster.compute_objective_function</code></a></li><li><a href="#Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}"><code>Cluster.fit!</code></a></li><li><a href="#Cluster.fit!-Tuple{KMeans, Matrix{Float64}}"><code>Cluster.fit!</code></a></li><li><a href="#Cluster.fit!-Tuple{DC, Matrix{Float64}}"><code>Cluster.fit!</code></a></li><li><a href="#Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, Symbol}"><code>Cluster.init_centroids</code></a></li><li><a href="#Cluster.predict-Tuple{KMeans, Matrix{Float64}}"><code>Cluster.predict</code></a></li><li><a href="#Cluster.predict-Tuple{DC, Matrix{Float64}}"><code>Cluster.predict</code></a></li><li><a href="#Cluster.predict-Tuple{BKMeans, Matrix{Float64}}"><code>Cluster.predict</code></a></li><li><a href="#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}"><code>Cluster.update_centroids</code></a></li><li><a href="#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}"><code>Cluster.update_centroids</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.BKMeans" href="#Cluster.BKMeans"><code>Cluster.BKMeans</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BKMeans</code></pre><p>A mutable struct for the Bisecting KMeans clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of clusters.</li><li><code>kmeans::KMeans</code>: An instance of the KMeans struct used for bisecting.</li><li><code>labels::Array{Int,1}</code>: Vector of labels for each data point.</li><li><code>centroids::Matrix{Float64}</code>: Matrix of centroid coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
BKMeans(3, KMeans(2, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.BKMeans-Tuple{}" href="#Cluster.BKMeans-Tuple{}"><code>Cluster.BKMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BKMeans(; k::Int=3, kmeans::KMeans=KMeans(k=2, mode=:kmeanspp))</code></pre><p>Constructor for the BKMeans struct.</p><p><strong>Input</strong></p><ul><li><code>k::Int</code>: Number of clusters (default: 3).</li><li><code>kmeans::KMeans</code>: An instance of the KMeans struct used for bisecting (default: KMeans(k=2, mode=:kmeanspp)).</li></ul><p><strong>Output</strong></p><ul><li>Returns an instance of <code>BKMeans</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
BKMeans(3, KMeans(2, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L26-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.DC" href="#Cluster.DC"><code>Cluster.DC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DC</code></pre><p>A mutable struct for the Density-based Clustering (DC) algorithm.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of clusters.</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>.</li><li><code>max_try::Int</code>: Maximum number of iterations.</li><li><code>tol::Float64</code>: Tolerance for convergence.</li><li><code>centroids::Array{Float64,2}</code>: Matrix of centroid coordinates.</li><li><code>labels::Array{Int,1}</code>: Vector of labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3, mode=:random, max_try=100, tol=1e-4)
DC(3, :random, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.DC-Tuple{}" href="#Cluster.DC-Tuple{}"><code>Cluster.DC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DC(; k::Int=3, mode::Symbol=:kmeanspp, max_try::Int=100, tol::Float64=1e-4)</code></pre><p>Constructor for the DC struct.</p><p><strong>Input</strong></p><ul><li><code>k::Int</code>: Number of clusters (default: 3).</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>(default: :kmeanspp).</li><li><code>max_try::Int</code>: Maximum number of iterations (default: 100).</li><li><code>tol::Float64</code>: Tolerance for convergence (default: 1e-4).</li></ul><p><strong>Output</strong></p><ul><li>Returns an instance of <code>DC</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3, mode=:kmeanspp, max_try=100, tol=1e-4)
DC(3, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.KMeans" href="#Cluster.KMeans"><code>Cluster.KMeans</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct KMeans</code></pre><p>A mutable struct for the KMeans clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>k::Int</code>: Number of clusters.</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>.</li><li><code>max_try::Int</code>: Maximum number of iterations.</li><li><code>tol::Float64</code>: Tolerance for convergence.</li><li><code>centroids::Array{Float64,2}</code>: Matrix of centroid coordinates.</li><li><code>labels::Array{Int,1}</code>: Vector of labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3, mode=:kmeanspp, max_try=100, tol=1e-4)
KMeans(3, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.KMeans-Tuple{}" href="#Cluster.KMeans-Tuple{}"><code>Cluster.KMeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KMeans(; k::Int=3, mode::Symbol=:kmeanspp, max_try::Int=100, tol::Float64=1e-4)</code></pre><p>Constructor for the KMeans struct.</p><p><strong>Input</strong></p><ul><li><code>k::Int</code>: Number of clusters (default: 3).</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code> (default: :kmeanspp).</li><li><code>max_try::Int</code>: Maximum number of iterations (default: 100).</li><li><code>tol::Float64</code>: Tolerance for convergence (default: 1e-4).</li></ul><p><strong>Output</strong></p><ul><li>Returns an instance of <code>KMeans</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3, mode=:kmeanspp, max_try=100, tol=1e-4)
KMeans(3, :kmeanspp, 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.assign_center-Tuple{Matrix{Float64}}" href="#Cluster.assign_center-Tuple{Matrix{Float64}}"><code>Cluster.assign_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_center(D::Matrix{Float64})</code></pre><p>Assigns each data point to the nearest centroid based on the distance matrix D.</p><p><strong>Input</strong></p><ul><li><code>D::Matrix{Float64}</code>: Distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of labels where each element is the index of the nearest centroid for the corresponding data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = rand(100, 3)
julia&gt; labels = assign_center(D)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L158-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}" href="#Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}"><code>Cluster.compute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_distance(X::Matrix{Float64}, centroids::Matrix{Float64})</code></pre><p>Computes the distance between each data point in X and each centroid.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>centroids::Matrix{Float64}</code>: Matrix of centroid coordinates.</li></ul><p><strong>Output</strong></p><ul><li>Returns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; centroids = rand(3, 2)
julia&gt; D = compute_distance(X, centroids)
100×3 Matrix{Float64}:
 0.181333  0.539578  0.306867
 0.754863  0.48797   0.562147
 0.205116  0.360735  0.127107
 0.154926  0.552747  0.323433
 ⋮
 0.434321  0.321914  0.261909
 0.773258  0.291669  0.513668
 0.607547  0.310411  0.38714</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L117-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}" href="#Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}"><code>Cluster.compute_objective_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_objective_function(X::Matrix{Float64}, centroids::Matrix{Float64}; p=2, delta=0.0001)</code></pre><p>Computes the objective function for the DC algorithm.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>centroids::Matrix{Float64}</code>: Matrix of centroid coordinates.</li><li><code>p</code>: Power parameter for the distance metric (default: 2).</li><li><code>delta</code>: Small constant to avoid division by zero (default: 0.0001).</li></ul><p><strong>Output</strong></p><ul><li>Returns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; centroids = rand(3, 2)
julia&gt; D = compute_objective_function(X, centroids)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}" href="#Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}"><code>Cluster.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::BKMeans, X::Matrix{Float64})</code></pre><p>Fits the BKMeans model to the data matrix X.</p><p><strong>Input</strong></p><ul><li><code>model::BKMeans</code>: An instance of <code>BKMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Modifies the <code>model</code> in-place to fit the data.</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize clusters with the entire dataset.</li><li>While the number of clusters is less than <code>k</code>:  a. Compute the sum of squared errors (SSE) for each cluster.  b. Select the cluster with the highest SSE.  c. Apply KMeans to bisect the selected cluster.  d. Replace the selected cluster with the two resulting clusters.</li><li>Assign labels and centroids based on the final clusters.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
julia&gt; X = rand(100, 2)
julia&gt; fit!(model, X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L55-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.fit!-Tuple{DC, Matrix{Float64}}" href="#Cluster.fit!-Tuple{DC, Matrix{Float64}}"><code>Cluster.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::DC, X::Matrix{Float64})</code></pre><p>Fits the DC model to the data matrix X.</p><p><strong>Input</strong></p><ul><li><code>model::DC</code>: An instance of <code>DC</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Modifies the <code>model</code> in-place to fit the data.</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize centroids.</li><li>Iterate up to <code>max_try</code> times:  a. Compute the objective function between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the current assignment.  d. Check for convergence based on <code>tol</code>.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3)
julia&gt; X = rand(100, 2)
julia&gt; fit!(model, X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L144-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.fit!-Tuple{KMeans, Matrix{Float64}}" href="#Cluster.fit!-Tuple{KMeans, Matrix{Float64}}"><code>Cluster.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::KMeans, X::Matrix{Float64})</code></pre><p>Fits the KMeans model to the data matrix X.</p><p><strong>Input</strong></p><ul><li><code>model::KMeans</code>: An instance of <code>KMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Modifies the <code>model</code> in-place to fit the data.</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize centroids.</li><li>Iterate up to <code>max_try</code> times:  a. Compute distances between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the mean of assigned data points.  d. Check for convergence based on <code>tol</code>.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3)
julia&gt; X = rand(100, 2)
julia&gt; fit!(model, X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L65-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, Symbol}" href="#Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, Symbol}"><code>Cluster.init_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_centroids(X::Matrix{Float64}, K::Int64, mode::Symbol)</code></pre><p>Initializes centroids for the clustering algorithm based on the specified mode.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>K::Int64</code>: Number of clusters.</li><li><code>mode::Symbol</code>: Initialization mode, either <code>:random</code> or <code>:kmeanspp</code>.</li></ul><p><strong>Output</strong></p><ul><li>Returns a matrix of initialized centroid coordinates.</li></ul><p><strong>Algorithm</strong></p><ol><li>If <code>mode</code> is <code>:random</code>:<ul><li>Randomly select K data points from X as initial centroids.</li></ul></li><li>If <code>mode</code> is <code>:kmeanspp</code>:<ul><li>Initialize the first centroid randomly.</li><li>For each subsequent centroid:   a. Compute the distance from each data point to the nearest centroid.   b. Select the next centroid with probability proportional to the squared distance.</li></ul></li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; centroids = init_centroids(X, 3, :kmeanspp)
3×2 Matrix{Float64}:
 0.386814  0.619566
 0.170768  0.0176449
 0.38688   0.398064</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/utils.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.predict-Tuple{BKMeans, Matrix{Float64}}" href="#Cluster.predict-Tuple{BKMeans, Matrix{Float64}}"><code>Cluster.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(model::BKMeans, X::Matrix{Float64})</code></pre><p>Predicts the cluster labels for new data points based on the fitted BKMeans model.</p><p><strong>Input</strong></p><ul><li><code>model::BKMeans</code>: An instance of <code>BKMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of predicted labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kmeans_model = KMeans(k=2, mode=:kmeanspp)
julia&gt; model = BKMeans(k=3, kmeans=kmeans_model)
julia&gt; X_train = rand(100, 2)
julia&gt; fit!(model, X_train)
julia&gt; X_test = rand(10, 2)
julia&gt; labels = predict(model, X_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/BKMeans.jl#L116-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.predict-Tuple{DC, Matrix{Float64}}" href="#Cluster.predict-Tuple{DC, Matrix{Float64}}"><code>Cluster.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(model::DC, X::Matrix{Float64})</code></pre><p>Predicts the cluster labels for new data points based on the fitted DC model.</p><p><strong>Input</strong></p><ul><li><code>model::DC</code>: An instance of <code>DC</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of predicted labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DC(k=3)
julia&gt; X_train = rand(100, 2)
julia&gt; fit!(model, X_train)
julia&gt; X_test = rand(10, 2)
julia&gt; labels = predict(model, X_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L194-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.predict-Tuple{KMeans, Matrix{Float64}}" href="#Cluster.predict-Tuple{KMeans, Matrix{Float64}}"><code>Cluster.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(model::KMeans, X::Matrix{Float64})</code></pre><p>Predicts the cluster labels for new data points based on the fitted model.</p><p><strong>Input</strong></p><ul><li><code>model::KMeans</code>: An instance of <code>KMeans</code>.</li><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li></ul><p><strong>Output</strong></p><ul><li>Returns a vector of predicted labels for each data point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = KMeans(k=3)
julia&gt; X_train = rand(100, 2)
julia&gt; fit!(model, X_train)
julia&gt; X_test = rand(10, 2)
julia&gt; labels = predict(model, X_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L212-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}" href="#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}"><code>Cluster.update_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::DC; delta=0.0001)</code></pre><p>Updates the centroids based on the current assignment of data points to centroids.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>label_vector::Vector{Int64}</code>: Vector of labels for each data point.</li><li><code>model::DC</code>: An instance of <code>DC</code>.</li><li><code>delta</code>: Small constant to avoid division by zero (default: 0.0001).</li></ul><p><strong>Output</strong></p><ul><li>Returns a matrix of updated centroid coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; labels = rand(1:3, 100)
julia&gt; model = DC(k=3)
julia&gt; centroids = update_centroids(X, labels, model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/DC.jl#L99-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}" href="#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}"><code>Cluster.update_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::KMeans)</code></pre><p>Updates the centroids based on the current assignment of data points to centroids.</p><p><strong>Input</strong></p><ul><li><code>X::Matrix{Float64}</code>: Data matrix where rows are data points and columns are features.</li><li><code>label_vector::Vector{Int64}</code>: Vector of labels for each data point.</li><li><code>model::KMeans</code>: An instance of <code>KMeans</code>.</li></ul><p><strong>Output</strong></p><ul><li>Returns a matrix of updated centroid coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = rand(100, 2)
julia&gt; labels = rand(1:3, 100)
julia&gt; model = KMeans(k=3)
julia&gt; centroids = update_centroids(X, labels, model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viktorlorentz/Cluster.jl/blob/8af3d81143495e79a4adb5b0320a2a3986477b71/src/KMeans.jl#L179-L199">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 16 July 2024 20:40">Tuesday 16 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
