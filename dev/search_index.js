var documenterSearchIndex = {"docs":
[{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"CurrentModule = Cluster","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For benchmark our project we used the dataset provided by Marek Gagolewski. Specificallyh we are using wut dataset. Below you can see the table with our metrics of rand index and accuracy of our algorithms: kmeans and kmeans++ which was benchmarked on wut dataset. Also, we are providing visualization in order to give insights what data we used.","category":"page"},{"location":"benchmarks/#Comparison-table","page":"Benchmarks","title":"Comparison table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Test Case Kmeans Rand Index Kmeans Accuracy Kmeans++ Rand Index Kmeans++ Accuracy Bkmeans Rand Index Bkmeans Accuracy\ncircles 1.00 1.00 1.00 1.00 1.0 1.0\ncross 0.5905 0.5967 0.5905 0.5967 0.7362 0.7167\ngraph 0.8835 0.2373 0.8852 0.6133 0.8687 0.3147\nisolation 0.5564 0.3474 0.5557 0.3444 0.5543 0.3489\nlabirynth 0.7526 0.4511 0.7526 0.4511 0.7839 0.2350\nmk1 1.00 1.00 1.00 1.00 1.0 1.0\nmk2 0.5010 0.5467 0.5010 0.5467 0.5010 0.5467\nmk3 0.9740 0.9778 0.9740 0.9778 0.9740 0.9778\nmk4 0.5682 0.2311 0.5766 0.2400 0.6224 0.5111\nolympic 0.7122 0.2907 0.7306 0.2707 0.7110 0.2840\nsmile 0.8263 0.4267 0.8379 0.5267 0.8335 0.5733\nstripes 0.4998 0.5160 0.4998 0.5160 0.4998 0.5160\ntrajectories 1.00 1.00 1.00 1.00 1.0 1.0\ntrapped_lovers 0.5973 0.5840 0.5955 0.5813 0.5833 0.4533\ntwosplashes 0.6186 0.7500 0.6186 0.7500 0.6186 0.7500\nwindows 0.5745 0.3333 0.5677 0.3535 0.5820 0.4855\nx1 1.00 1.00 1.00 1.00 1.0 1.0\nx2 0.8301 0.8889 0.6078 0.6667 0.6078 0.6667\nx3 0.9259 0.9286 0.9339 0.6429 0.9339 0.6429\nz1 0.6256 0.4828 0.6256 0.4828 0.6650 0.5862\nz2 0.7803 0.3333 0.7803 0.3333 0.7772 0.2963\nz3 1.00 1.00 1.00 1.00 1.0 1.0","category":"page"},{"location":"benchmarks/#Visualization-K-means","page":"Benchmarks","title":"Visualization K-means","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<div style=\"text-align: center;\">\n  <img src=\"https://github.com/viktorlorentz/Cluster.jl/blob/benchmarking_alg/test/kmeans-figures/circles.png?raw=true\" alt=\"Clustering Circles\">\n  <p>Figure 1: Clustering Circles with K-means</p>\n</div>\n\n<div style=\"text-align: center;\">\n  <img src=\"https://github.com/viktorlorentz/Cluster.jl/blob/benchmarking_alg/test/kmeans-figures/mk1.png?raw=true\" alt=\"Mk1\">\n  <p>Figure 2: Mk1 with K-means</p>\n</div>\n\n<div style=\"text-align: center;\">\n  <img src=\"https://github.com/viktorlorentz/Cluster.jl/blob/benchmarking_alg/test/kmeans-figures/mk3.png?raw=true\" alt=\"Mk1\">\n  <p>Figure 3: Mk3 with K-means</p>\n</div>\n\n<div style=\"text-align: center;\">\n  <img src=\"https://github.com/viktorlorentz/Cluster.jl/blob/benchmarking_alg/test/kmeans-figures/z3.png?raw=true\" alt=\"Mk1\">\n  <p>Figure 4: Z3 with K-means</p>\n</div>\n\n<div style=\"text-align: center;\">\n  <img src=\"https://github.com/viktorlorentz/Cluster.jl/blob/benchmarking_alg/test/kmeans-figures/trajectories.png?raw=true\" alt=\"Mk1\">\n  <p>Figure 5: Trajectories with K-means</p>\n</div>","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Cluster","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 2:3","category":"page"},{"location":"api/#Utility-functions","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"All functions used by all algorithms.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Cluster]\nPages = [\"src/utils.jl\"]","category":"page"},{"location":"api/#Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, String}-api","page":"API","title":"Cluster.init_centroids","text":"init_centroids(X::Matrix{Float64}, K::Int64, mode::String)\n\nInitializes centroids for the clustering algorithm based on the specified mode.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\nK::Int64: Number of clusters.\nmode::String: Initialization mode, either \"kmeans\", \"kmeanspp\", or \"dc\".\n\nOutput\n\nReturns a matrix of initialized centroid coordinates.\n\nAlgorithm\n\nIf mode is \"kmeans\" or \"dc\":\nRandomly select K data points from X as initial centroids.\nIf mode is \"kmeanspp\":\nInitialize the first centroid randomly.\nFor each subsequent centroid:   a. Compute the distance from each data point to the nearest centroid.   b. Select the next centroid with probability proportional to the squared distance.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> centroids = init_centroids(X, 3, \"kmeans\")\n3×2 Matrix{Float64}:\n 0.386814  0.619566\n 0.170768  0.0176449\n 0.38688   0.398064\n\n\n\n\n\n","category":"method"},{"location":"api/#KMeans-/-KMeans-Clustering-Algorithm","page":"API","title":"KMeans / KMeans++ Clustering Algorithm","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Initializes centroids using either random selection or KMeans++.\nIteratively assigns points to the nearest centroid.\nUpdates centroids based on the mean of assigned points.\nStops when centroids converge or after a maximum number of iterations.","category":"page"},{"location":"api/","page":"API","title":"API","text":"References:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Scikit-Learn KMeans Documentation","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Cluster]\nPages = [\"src/KMeans.jl\"]","category":"page"},{"location":"api/#Cluster.KMeans-Tuple{}-api-2","page":"API","title":"Cluster.KMeans","text":"KMeans(; k::Int=3, mode::String=\"kmeans\", max_try::Int=100, tol::Float64=1e-4)\n\nConstructor for the KMeans struct.\n\nInput\n\nk::Int: Number of clusters (default: 3).\nmode::String: Initialization mode, either \"kmeans\" or \"kmeanspp\" (default: \"kmeans\").\nmax_try::Int: Maximum number of iterations (default: 100).\ntol::Float64: Tolerance for convergence (default: 1e-4).\n\nOutput\n\nReturns an instance of KMeans.\n\nExamples\n\njulia> model = KMeans(k=3, mode=\"kmeans\", max_try=100, tol=1e-4)\nKMeans(3, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.KMeans-api-2","page":"API","title":"Cluster.KMeans","text":"mutable struct KMeans\n\nA mutable struct for the KMeans clustering algorithm.\n\nFields\n\nk::Int: Number of clusters.\nmode::String: Initialization mode, either \"kmeans\" or \"kmeanspp\".\nmax_try::Int: Maximum number of iterations.\ntol::Float64: Tolerance for convergence.\ncentroids::Array{Float64,2}: Matrix of centroid coordinates.\nlabels::Array{Int,1}: Vector of labels for each data point.\n\nExamples\n\njulia> model = KMeans(k=3, mode=\"kmeans\", max_try=100, tol=1e-4)\nKMeans(3, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"type"},{"location":"api/#Cluster.assign_center-Tuple{Matrix{Float64}}-api-2","page":"API","title":"Cluster.assign_center","text":"assign_center(D::Matrix{Float64})\n\nAssigns each data point to the nearest centroid based on the distance matrix D.\n\nInput\n\nD::Matrix{Float64}: Distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.\n\nOutput\n\nReturns a vector of labels where each element is the index of the nearest centroid for the corresponding data point.\n\nExamples\n\njulia> D = rand(100, 3)\njulia> labels = assign_center(D)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}-api-2","page":"API","title":"Cluster.compute_distance","text":"compute_distance(X::Matrix{Float64}, centroids::Matrix{Float64})\n\nComputes the distance between each data point in X and each centroid.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\ncentroids::Matrix{Float64}: Matrix of centroid coordinates.\n\nOutput\n\nReturns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> centroids = rand(3, 2)\njulia> D = compute_distance(X, centroids)\n100×3 Matrix{Float64}:\n 0.181333  0.539578  0.306867\n 0.754863  0.48797   0.562147\n 0.205116  0.360735  0.127107\n 0.154926  0.552747  0.323433\n ⋮\n 0.434321  0.321914  0.261909\n 0.773258  0.291669  0.513668\n 0.607547  0.310411  0.38714\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.fit!-Tuple{KMeans, Matrix{Float64}}-api-2","page":"API","title":"Cluster.fit!","text":"fit!(model::KMeans, X::Matrix{Float64})\n\nFits the KMeans model to the data matrix X.\n\nInput\n\nmodel::KMeans: An instance of KMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nModifies the model in-place to fit the data.\n\nAlgorithm\n\nInitialize centroids.\nIterate up to max_try times:  a. Compute distances between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the mean of assigned data points.  d. Check for convergence based on tol.\n\nExamples\n\njulia> model = KMeans(k=3)\njulia> X = rand(100, 2)\njulia> fit!(model, X)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.predict-Tuple{KMeans, Matrix{Float64}}-api-2","page":"API","title":"Cluster.predict","text":"predict(model::KMeans, X::Matrix{Float64})\n\nPredicts the cluster labels for new data points based on the fitted model.\n\nInput\n\nmodel::KMeans: An instance of KMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nReturns a vector of predicted labels for each data point.\n\nExamples\n\njulia> model = KMeans(k=3)\njulia> X_train = rand(100, 2)\njulia> fit!(model, X_train)\njulia> X_test = rand(10, 2)\njulia> labels = predict(model, X_test)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}-api-2","page":"API","title":"Cluster.update_centroids","text":"update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::KMeans)\n\nUpdates the centroids based on the current assignment of data points to centroids.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\nlabel_vector::Vector{Int64}: Vector of labels for each data point.\nmodel::KMeans: An instance of KMeans.\n\nOutput\n\nReturns a matrix of updated centroid coordinates.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> labels = rand(1:3, 100)\njulia> model = KMeans(k=3)\njulia> centroids = update_centroids(X, labels, model)\n\n\n\n\n\n","category":"method"},{"location":"api/#Bisecting-KMeans-Clustering-Algorithm","page":"API","title":"Bisecting KMeans Clustering Algorithm","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Starts with a single cluster containing all data points.\nRecursively splits clusters based on the highest SSE until k clusters are obtained.\nUses standard KMeans for cluster splitting.","category":"page"},{"location":"api/","page":"API","title":"API","text":"References:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Bisecting KMeans: An Improved Version of KMeans","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Cluster]\nPages = [\"src/BKMeans.jl\"]","category":"page"},{"location":"api/#Cluster.BKMeans-Tuple{}-api-3","page":"API","title":"Cluster.BKMeans","text":"BKMeans(; k::Int=3, kmeans::KMeans=KMeans(k=2, mode=\"kmeans\"))\n\nConstructor for the BKMeans struct.\n\nInput\n\nk::Int: Number of clusters (default: 3).\nkmeans::KMeans: An instance of the KMeans struct used for bisecting (default: KMeans(k=2, mode=\"kmeans\")).\n\nOutput\n\nReturns an instance of BKMeans.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\nBKMeans(3, KMeans(2, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.BKMeans-api-3","page":"API","title":"Cluster.BKMeans","text":"mutable struct BKMeans\n\nA mutable struct for the Bisecting KMeans clustering algorithm.\n\nFields\n\nk::Int: Number of clusters.\nkmeans::KMeans: An instance of the KMeans struct used for bisecting.\nlabels::Array{Int,1}: Vector of labels for each data point.\ncentroids::Matrix{Float64}: Matrix of centroid coordinates.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\nBKMeans(3, KMeans(2, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))\n\n\n\n\n\n","category":"type"},{"location":"api/#Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}-api-3","page":"API","title":"Cluster.fit!","text":"fit!(model::BKMeans, X::Matrix{Float64})\n\nFits the BKMeans model to the data matrix X.\n\nInput\n\nmodel::BKMeans: An instance of BKMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nModifies the model in-place to fit the data.\n\nAlgorithm\n\nInitialize clusters with the entire dataset.\nWhile the number of clusters is less than k:  a. Compute the sum of squared errors (SSE) for each cluster.  b. Select the cluster with the highest SSE.  c. Apply KMeans to bisect the selected cluster.  d. Replace the selected cluster with the two resulting clusters.\nAssign labels and centroids based on the final clusters.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\njulia> X = rand(100, 2)\njulia> fit!(model, X)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.predict-Tuple{BKMeans, Matrix{Float64}}-api-3","page":"API","title":"Cluster.predict","text":"predict(model::BKMeans, X::Matrix{Float64})\n\nPredicts the cluster labels for new data points based on the fitted BKMeans model.\n\nInput\n\nmodel::BKMeans: An instance of BKMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nReturns a vector of predicted labels for each data point.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\njulia> X_train = rand(100, 2)\njulia> fit!(model, X_train)\njulia> X_test = rand(10, 2)\njulia> labels = predict(model, X_test)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributional-Clustering-Method","page":"API","title":"Distributional Clustering Method","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"References:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Krishna, A., Mak, S. and Joseph, R., 2019. Distributional clustering: A distribution-preserving clustering method. arXiv preprint arXiv:1911.05940","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Cluster]\nPages = [\"src/DC.jl\"]","category":"page"},{"location":"api/#Cluster.DC-Tuple{}-api-4","page":"API","title":"Cluster.DC","text":"DC(; k::Int=3, mode::String=\"dc\", max_try::Int=100, tol::Float64=1e-4)\n\nConstructor for the DC struct.\n\nInput\n\nk::Int: Number of clusters (default: 3).\nmode::String: Initialization mode, either \"kmeans\", \"kmeanspp\", or \"dc\" (default: \"dc\").\nmax_try::Int: Maximum number of iterations (default: 100).\ntol::Float64: Tolerance for convergence (default: 1e-4).\n\nOutput\n\nReturns an instance of DC.\n\nExamples\n\njulia> model = DC(k=3, mode=\"dc\", max_try=100, tol=1e-4)\nDC(3, \"dc\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.DC-api-4","page":"API","title":"Cluster.DC","text":"mutable struct DC\n\nA mutable struct for the Density-based Clustering (DC) algorithm.\n\nFields\n\nk::Int: Number of clusters.\nmode::String: Initialization mode, either \"kmeans\", \"kmeanspp\", or \"dc\".\nmax_try::Int: Maximum number of iterations.\ntol::Float64: Tolerance for convergence.\ncentroids::Array{Float64,2}: Matrix of centroid coordinates.\nlabels::Array{Int,1}: Vector of labels for each data point.\n\nExamples\n\njulia> model = DC(k=3, mode=\"dc\", max_try=100, tol=1e-4)\nDC(3, \"dc\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"type"},{"location":"api/#Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}-api-4","page":"API","title":"Cluster.compute_objective_function","text":"compute_objective_function(X::Matrix{Float64}, centroids::Matrix{Float64}; p=2, delta=0.0001)\n\nComputes the objective function for the DC algorithm.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\ncentroids::Matrix{Float64}: Matrix of centroid coordinates.\np: Power parameter for the distance metric (default: 2).\ndelta: Small constant to avoid division by zero (default: 0.0001).\n\nOutput\n\nReturns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> centroids = rand(3, 2)\njulia> D = compute_objective_function(X, centroids)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.fit!-Tuple{DC, Matrix{Float64}}-api-4","page":"API","title":"Cluster.fit!","text":"fit!(model::DC, X::Matrix{Float64})\n\nFits the DC model to the data matrix X.\n\nInput\n\nmodel::DC: An instance of DC.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nModifies the model in-place to fit the data.\n\nAlgorithm\n\nInitialize centroids.\nIterate up to max_try times:  a. Compute the objective function between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the current assignment.  d. Check for convergence based on tol.\n\nExamples\n\njulia> model = DC(k=3)\njulia> X = rand(100, 2)\njulia> fit!(model, X)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.predict-Tuple{DC, Matrix{Float64}}-api-4","page":"API","title":"Cluster.predict","text":"predict(model::DC, X::Matrix{Float64})\n\nPredicts the cluster labels for new data points based on the fitted DC model.\n\nInput\n\nmodel::DC: An instance of DC.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nReturns a vector of predicted labels for each data point.\n\nExamples\n\njulia> model = DC(k=3)\njulia> X_train = rand(100, 2)\njulia> fit!(model, X_train)\njulia> X_test = rand(10, 2)\njulia> labels = predict(model, X_test)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}-api-4","page":"API","title":"Cluster.update_centroids","text":"update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::DC; delta=0.0001)\n\nUpdates the centroids based on the current assignment of data points to centroids.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\nlabel_vector::Vector{Int64}: Vector of labels for each data point.\nmodel::DC: An instance of DC.\ndelta: Small constant to avoid division by zero (default: 0.0001).\n\nOutput\n\nReturns a matrix of updated centroid coordinates.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> labels = rand(1:3, 100)\njulia> model = DC(k=3)\njulia> centroids = update_centroids(X, labels, model)\n\n\n\n\n\n","category":"method"},{"location":"api/#Full-list-of-available-functions","page":"API","title":"Full list of available functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Cluster]","category":"page"},{"location":"api/#Cluster.BKMeans","page":"API","title":"Cluster.BKMeans","text":"mutable struct BKMeans\n\nA mutable struct for the Bisecting KMeans clustering algorithm.\n\nFields\n\nk::Int: Number of clusters.\nkmeans::KMeans: An instance of the KMeans struct used for bisecting.\nlabels::Array{Int,1}: Vector of labels for each data point.\ncentroids::Matrix{Float64}: Matrix of centroid coordinates.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\nBKMeans(3, KMeans(2, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))\n\n\n\n\n\n","category":"type"},{"location":"api/#Cluster.BKMeans-Tuple{}","page":"API","title":"Cluster.BKMeans","text":"BKMeans(; k::Int=3, kmeans::KMeans=KMeans(k=2, mode=\"kmeans\"))\n\nConstructor for the BKMeans struct.\n\nInput\n\nk::Int: Number of clusters (default: 3).\nkmeans::KMeans: An instance of the KMeans struct used for bisecting (default: KMeans(k=2, mode=\"kmeans\")).\n\nOutput\n\nReturns an instance of BKMeans.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\nBKMeans(3, KMeans(2, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[]), Int64[], Matrix{Float64}(undef, 0, 0))\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.DC","page":"API","title":"Cluster.DC","text":"mutable struct DC\n\nA mutable struct for the Density-based Clustering (DC) algorithm.\n\nFields\n\nk::Int: Number of clusters.\nmode::String: Initialization mode, either \"kmeans\", \"kmeanspp\", or \"dc\".\nmax_try::Int: Maximum number of iterations.\ntol::Float64: Tolerance for convergence.\ncentroids::Array{Float64,2}: Matrix of centroid coordinates.\nlabels::Array{Int,1}: Vector of labels for each data point.\n\nExamples\n\njulia> model = DC(k=3, mode=\"dc\", max_try=100, tol=1e-4)\nDC(3, \"dc\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"type"},{"location":"api/#Cluster.DC-Tuple{}","page":"API","title":"Cluster.DC","text":"DC(; k::Int=3, mode::String=\"dc\", max_try::Int=100, tol::Float64=1e-4)\n\nConstructor for the DC struct.\n\nInput\n\nk::Int: Number of clusters (default: 3).\nmode::String: Initialization mode, either \"kmeans\", \"kmeanspp\", or \"dc\" (default: \"dc\").\nmax_try::Int: Maximum number of iterations (default: 100).\ntol::Float64: Tolerance for convergence (default: 1e-4).\n\nOutput\n\nReturns an instance of DC.\n\nExamples\n\njulia> model = DC(k=3, mode=\"dc\", max_try=100, tol=1e-4)\nDC(3, \"dc\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.KMeans","page":"API","title":"Cluster.KMeans","text":"mutable struct KMeans\n\nA mutable struct for the KMeans clustering algorithm.\n\nFields\n\nk::Int: Number of clusters.\nmode::String: Initialization mode, either \"kmeans\" or \"kmeanspp\".\nmax_try::Int: Maximum number of iterations.\ntol::Float64: Tolerance for convergence.\ncentroids::Array{Float64,2}: Matrix of centroid coordinates.\nlabels::Array{Int,1}: Vector of labels for each data point.\n\nExamples\n\njulia> model = KMeans(k=3, mode=\"kmeans\", max_try=100, tol=1e-4)\nKMeans(3, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"type"},{"location":"api/#Cluster.KMeans-Tuple{}","page":"API","title":"Cluster.KMeans","text":"KMeans(; k::Int=3, mode::String=\"kmeans\", max_try::Int=100, tol::Float64=1e-4)\n\nConstructor for the KMeans struct.\n\nInput\n\nk::Int: Number of clusters (default: 3).\nmode::String: Initialization mode, either \"kmeans\" or \"kmeanspp\" (default: \"kmeans\").\nmax_try::Int: Maximum number of iterations (default: 100).\ntol::Float64: Tolerance for convergence (default: 1e-4).\n\nOutput\n\nReturns an instance of KMeans.\n\nExamples\n\njulia> model = KMeans(k=3, mode=\"kmeans\", max_try=100, tol=1e-4)\nKMeans(3, \"kmeans\", 100, 0.0001, Matrix{Float64}(undef, 0, 0), Int64[])\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.assign_center-Tuple{Matrix{Float64}}","page":"API","title":"Cluster.assign_center","text":"assign_center(D::Matrix{Float64})\n\nAssigns each data point to the nearest centroid based on the distance matrix D.\n\nInput\n\nD::Matrix{Float64}: Distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.\n\nOutput\n\nReturns a vector of labels where each element is the index of the nearest centroid for the corresponding data point.\n\nExamples\n\njulia> D = rand(100, 3)\njulia> labels = assign_center(D)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.compute_distance-Tuple{Matrix{Float64}, Matrix{Float64}}","page":"API","title":"Cluster.compute_distance","text":"compute_distance(X::Matrix{Float64}, centroids::Matrix{Float64})\n\nComputes the distance between each data point in X and each centroid.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\ncentroids::Matrix{Float64}: Matrix of centroid coordinates.\n\nOutput\n\nReturns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> centroids = rand(3, 2)\njulia> D = compute_distance(X, centroids)\n100×3 Matrix{Float64}:\n 0.181333  0.539578  0.306867\n 0.754863  0.48797   0.562147\n 0.205116  0.360735  0.127107\n 0.154926  0.552747  0.323433\n ⋮\n 0.434321  0.321914  0.261909\n 0.773258  0.291669  0.513668\n 0.607547  0.310411  0.38714\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.compute_objective_function-Tuple{Matrix{Float64}, Matrix{Float64}}","page":"API","title":"Cluster.compute_objective_function","text":"compute_objective_function(X::Matrix{Float64}, centroids::Matrix{Float64}; p=2, delta=0.0001)\n\nComputes the objective function for the DC algorithm.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\ncentroids::Matrix{Float64}: Matrix of centroid coordinates.\np: Power parameter for the distance metric (default: 2).\ndelta: Small constant to avoid division by zero (default: 0.0001).\n\nOutput\n\nReturns a distance matrix where element (i, j) is the distance between the i-th data point and the j-th centroid.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> centroids = rand(3, 2)\njulia> D = compute_objective_function(X, centroids)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.fit!-Tuple{BKMeans, Matrix{Float64}}","page":"API","title":"Cluster.fit!","text":"fit!(model::BKMeans, X::Matrix{Float64})\n\nFits the BKMeans model to the data matrix X.\n\nInput\n\nmodel::BKMeans: An instance of BKMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nModifies the model in-place to fit the data.\n\nAlgorithm\n\nInitialize clusters with the entire dataset.\nWhile the number of clusters is less than k:  a. Compute the sum of squared errors (SSE) for each cluster.  b. Select the cluster with the highest SSE.  c. Apply KMeans to bisect the selected cluster.  d. Replace the selected cluster with the two resulting clusters.\nAssign labels and centroids based on the final clusters.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\njulia> X = rand(100, 2)\njulia> fit!(model, X)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.fit!-Tuple{DC, Matrix{Float64}}","page":"API","title":"Cluster.fit!","text":"fit!(model::DC, X::Matrix{Float64})\n\nFits the DC model to the data matrix X.\n\nInput\n\nmodel::DC: An instance of DC.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nModifies the model in-place to fit the data.\n\nAlgorithm\n\nInitialize centroids.\nIterate up to max_try times:  a. Compute the objective function between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the current assignment.  d. Check for convergence based on tol.\n\nExamples\n\njulia> model = DC(k=3)\njulia> X = rand(100, 2)\njulia> fit!(model, X)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.fit!-Tuple{KMeans, Matrix{Float64}}","page":"API","title":"Cluster.fit!","text":"fit!(model::KMeans, X::Matrix{Float64})\n\nFits the KMeans model to the data matrix X.\n\nInput\n\nmodel::KMeans: An instance of KMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nModifies the model in-place to fit the data.\n\nAlgorithm\n\nInitialize centroids.\nIterate up to max_try times:  a. Compute distances between data points and centroids.  b. Assign each data point to the nearest centroid.  c. Update centroids based on the mean of assigned data points.  d. Check for convergence based on tol.\n\nExamples\n\njulia> model = KMeans(k=3)\njulia> X = rand(100, 2)\njulia> fit!(model, X)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.init_centroids-Tuple{Matrix{Float64}, Int64, String}","page":"API","title":"Cluster.init_centroids","text":"init_centroids(X::Matrix{Float64}, K::Int64, mode::String)\n\nInitializes centroids for the clustering algorithm based on the specified mode.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\nK::Int64: Number of clusters.\nmode::String: Initialization mode, either \"kmeans\", \"kmeanspp\", or \"dc\".\n\nOutput\n\nReturns a matrix of initialized centroid coordinates.\n\nAlgorithm\n\nIf mode is \"kmeans\" or \"dc\":\nRandomly select K data points from X as initial centroids.\nIf mode is \"kmeanspp\":\nInitialize the first centroid randomly.\nFor each subsequent centroid:   a. Compute the distance from each data point to the nearest centroid.   b. Select the next centroid with probability proportional to the squared distance.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> centroids = init_centroids(X, 3, \"kmeans\")\n3×2 Matrix{Float64}:\n 0.386814  0.619566\n 0.170768  0.0176449\n 0.38688   0.398064\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.predict-Tuple{BKMeans, Matrix{Float64}}","page":"API","title":"Cluster.predict","text":"predict(model::BKMeans, X::Matrix{Float64})\n\nPredicts the cluster labels for new data points based on the fitted BKMeans model.\n\nInput\n\nmodel::BKMeans: An instance of BKMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nReturns a vector of predicted labels for each data point.\n\nExamples\n\njulia> kmeans_model = KMeans(k=2, mode=\"kmeans\")\njulia> model = BKMeans(k=3, kmeans=kmeans_model)\njulia> X_train = rand(100, 2)\njulia> fit!(model, X_train)\njulia> X_test = rand(10, 2)\njulia> labels = predict(model, X_test)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.predict-Tuple{DC, Matrix{Float64}}","page":"API","title":"Cluster.predict","text":"predict(model::DC, X::Matrix{Float64})\n\nPredicts the cluster labels for new data points based on the fitted DC model.\n\nInput\n\nmodel::DC: An instance of DC.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nReturns a vector of predicted labels for each data point.\n\nExamples\n\njulia> model = DC(k=3)\njulia> X_train = rand(100, 2)\njulia> fit!(model, X_train)\njulia> X_test = rand(10, 2)\njulia> labels = predict(model, X_test)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.predict-Tuple{KMeans, Matrix{Float64}}","page":"API","title":"Cluster.predict","text":"predict(model::KMeans, X::Matrix{Float64})\n\nPredicts the cluster labels for new data points based on the fitted model.\n\nInput\n\nmodel::KMeans: An instance of KMeans.\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\n\nOutput\n\nReturns a vector of predicted labels for each data point.\n\nExamples\n\njulia> model = KMeans(k=3)\njulia> X_train = rand(100, 2)\njulia> fit!(model, X_train)\njulia> X_test = rand(10, 2)\njulia> labels = predict(model, X_test)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, DC}","page":"API","title":"Cluster.update_centroids","text":"update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::DC; delta=0.0001)\n\nUpdates the centroids based on the current assignment of data points to centroids.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\nlabel_vector::Vector{Int64}: Vector of labels for each data point.\nmodel::DC: An instance of DC.\ndelta: Small constant to avoid division by zero (default: 0.0001).\n\nOutput\n\nReturns a matrix of updated centroid coordinates.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> labels = rand(1:3, 100)\njulia> model = DC(k=3)\njulia> centroids = update_centroids(X, labels, model)\n\n\n\n\n\n","category":"method"},{"location":"api/#Cluster.update_centroids-Tuple{Matrix{Float64}, Vector{Int64}, KMeans}","page":"API","title":"Cluster.update_centroids","text":"update_centroids(X::Matrix{Float64}, label_vector::Vector{Int64}, model::KMeans)\n\nUpdates the centroids based on the current assignment of data points to centroids.\n\nInput\n\nX::Matrix{Float64}: Data matrix where rows are data points and columns are features.\nlabel_vector::Vector{Int64}: Vector of labels for each data point.\nmodel::KMeans: An instance of KMeans.\n\nOutput\n\nReturns a matrix of updated centroid coordinates.\n\nExamples\n\njulia> X = rand(100, 2)\njulia> labels = rand(1:3, 100)\njulia> model = KMeans(k=3)\njulia> centroids = update_centroids(X, labels, model)\n\n\n\n\n\n","category":"method"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = Cluster","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Basic-Example","page":"Examples","title":"Basic Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below is a basic usage example of the cluster.jl package. This example demonstrates how to set up and use the package with a dataset that has distinct clusters.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Load the Cluster.jl package\nusing Cluster\nusing Random\n\n# Set the random seed for reproducibility\nRandom.seed!(1234)\n\n# Create a simple 30x2 dataset with distinct clusters\ndata = vcat(\n    [randn(10, 2) .+ [1 1]; # Cluster 1 around [1, 1]\n        randn(10, 2) .+ [5 5]; # Cluster 2 around [5, 5]\n        randn(10, 2) .+ [9 1]] # Cluster 3 around [9, 1]\n)\n\n# Print the first 3 data points\nprintln(\"Data: \", data[1:3, :])\n\n# Print the shape of the data\nprintln(\"Shape: \", size(data))\n\n# Initialize the clustering algorithm\nmodel = Cluster.KMeans(k=3, mode=\"kmeans\") # also supports \"kmeanspp\"\n\n# Fit the model to the data\nCluster.fit!(model, data)\n\n# Print the centroids of the clusters\nprintln(\"Centroids: \", model.centroids)\n\n# Test Data\ntest_data = [\n    1.0 1.0; # Cluster 1\n    1.5 2.0; # Cluster 1\n    0.5 1.5; # Cluster 1\n    5.0 5.0; # Cluster 2\n    8.0 9.0; # Cluster 2\n    4.5 5.5; # Cluster 2\n    9.0 1.0  # Cluster 3\n    9.5 1.5  # Cluster 3\n    8.5 1.0  # Cluster 3\n]\n\nprintln(\"Test Data: \", test_data)\nprintln(\"Note: The labels might differ from the original cluster labels due to random initialization.\")\n\n\n# Predict the cluster for each data point\nclusters = Cluster.predict(model, test_data)\n\n# Print the resulting clusters\nprintln(\"Cluster assignments: \", clusters)\n\n# Plot the clusters\nusing Plots\nscatter(data[:, 1], data[:, 2], color=model.labels, legend=false)\nscatter!(model.centroids[:, 1], model.centroids[:, 2], color=:red, shape=:star, markersize=10)\nsavefig(\"simple-cluster.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is the resulting plot of the clusters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Interactive-Example-Notebook","page":"Examples","title":"Interactive Example Notebook","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This mike take some time to load, but you can run the example notebook in your browser by clicking the Binder link below. Here you can play around with generating different datasets and clustering them using the Cluster.jl package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Binder)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cluster","category":"page"},{"location":"#Cluster.jl","page":"Home","title":"Cluster.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cluster.jl. This is a package for clustering algorithms in Julia. It was created by a group of students as part of a project for the course \"Julia for Machine Learning\" at TU Berlin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Do not use this package\nPlease instead use the Clustering.jl package for a more complete and maintained package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/viktorlorentz/Cluster.jl\")","category":"page"}]
}
